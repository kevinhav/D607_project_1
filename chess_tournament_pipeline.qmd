---
title: "Chess Tournament Database Pipeline"
author: "Kevin Havis"
format: pdf
editor: visual
---

## Introduction

## Loading the data

```{r}
library(tidyverse)
library(purrr)
library(DBI)
library(duckdb)
library(tools)
```

## Reading the data

```{r}

# Pre-define our initial column names
init_cols = c(
  'pairNum_state',
  'player_info',
  'total',
  'round_1',
  'round_2',
  'round_3',
  'round_4',
  'round_5',
  'round_6',
  'round_7'
)

# Create a tibble by splitting row-wise by line breaks
# and column-wise by pipe
df <- tibble(txt = read_lines('tournament_info.txt')) |> 
  separate_rows(sep = '\\n') |> 
  separate(col = txt, into = init_cols, sep = '\\|')

# Drop --- row separators
df <- na.omit(df)

# Drop secondary header
df <- df |> 
  slice(-(1:2))
```

```{r}
# We have two rows per player so we group them and create new columns

df <- df |> 
  group_by(grp = ceiling(row_number()/2)) |> 
  mutate(row = row_number()) |> 
  pivot_wider(names_from = row, values_from = -c(row, grp)) |> 
  ungroup() |> 
  select(-grp) |> 
  mutate(across(everything(), ~ str_trim(.x)))
```

```{r}
# Update column names
col_names = c(
  "player",
  "state",
  "name",
  "rating_info",
  "total_pts",
  "n",
  "results_rd_1",
  "color_rd_1",
  "results_rd_2",
  "color_rd_2",
  "results_rd_3",
  "color_rd_3",
  "results_rd_4",
  "color_rd_4",
  "results_rd_5",
  "color_rd_5",
  "results_rd_6",
  "color_rd_6",
  "results_rd_7",
  "color_rd_7"
)

df <- df |> set_names(col_names)

```

```{r}
# Split results columns into single columns
df <- df |> 
 separate_wider_regex(
   starts_with("results"),
   patterns = c(
     result = "[WLDBH]",
     opponent = "\\s+\\d+"),
   names_sep = "_",
   too_few = "align_start") |> 
  mutate(across(starts_with("results"), ~ str_trim(.x)))
```

```{r}
# Retrieve USCF ID
uscf_id <- df |> 
  select(rating_info) |> 
  filter(str_detect(rating_info, "[0-9]{8}")) |> 
  mutate(uscf_id = str_extract(rating_info, "([0-9]{8})")) |> 
  select(uscf_id)

# Retrieve pre_rating
pre_rating <- df |> 
  select(rating_info) |> 
  filter(str_detect(rating_info, "[0-9]{8}")) |> 
  mutate(pre_rating = str_extract(rating_info, "(?<=R:\\s{1,5})\\d+")) |> 
  select(pre_rating)

# Retrieve post_rating
post_rating <- df |> 
  select(rating_info) |> 
  filter(str_detect(rating_info, "[0-9]{8}")) |> 
  mutate(post_rating = str_extract(rating_info, "(?<=>\\s{0,5})\\d{3,4}")) |> 
  select(post_rating)

df <- df |> 
  cbind(uscf_id) |>
  cbind(pre_rating) |>
  cbind(post_rating) |>
  mutate(pre_rating = as.numeric(pre_rating)) |> 
  mutate(post_rating = as.numeric(post_rating)) |> 
  select(everything(), -rating_info)
```

```{r}
# Separate into logical tables

players <- df |> 
  select(player, state, name, pre_rating, post_rating, total_pts) |> 
  mutate(rating_change = post_rating - pre_rating) |> 
  mutate(name = str_to_title(name))

rounds <- df |>
  pivot_longer(
    cols = starts_with("results_rd_"),
    names_to = c("round", "type"),
    names_pattern = "results_rd_(\\d+)_(result|opponent)",
    values_to = "value"
  ) |>
  pivot_longer(
    cols = starts_with("color"),
    names_to = "color_col",
    values_to = "color"
  ) |> 
  pivot_wider(
    names_from = c("type"),
    values_from = c("value")
  ) |> 
  select(player, color, round, result, opponent)
```

## Calculate tournament stats

```{r}
average_ratings <- left_join(rounds, players, by = c("opponent" = "player")) |> 
  group_by(player) |> 
  summarize(average_opponent_rating = mean(pre_rating, na.rm = TRUE))

players <- left_join(players, average_ratings, by = "player")
```

## Build final table

```{r}
# player name, player state, total, pre_rating, average pre_rating

final_table <- players |> 
  select(player, name, state, total_pts, pre_rating, average_opponent_rating)

```

## Save into database

```{r}
# Give rounds a unique ID as a key
rounds <- rounds |> 
  mutate(id = row_number())
  
conn <- DBI::dbConnect(duckdb::duckdb(), dbdir = "tournament.db")

# Write tables if they don't already exist
if (!dbExistsTable(conn, "players")) {
dbWriteTable(conn, "players", players)
} else {
  print("Table already exists, skipping write. \n")
}


if (!dbExistsTable(conn, "rounds")) {
dbWriteTable(conn, "rounds", rounds)
} else {
  print("Table already exists, skipping write. \n")
}


dbDisconnect(conn)
```

## Tournament Results

```{r fig.align="center", echo = FALSE, fig.wdith = 14, fig.height=10}
players_viz <- players |> 
  select(name, pre_rating, post_rating) |> 
  pivot_longer(
    c("pre_rating", "post_rating"),
    names_to = c("type"),
    values_to = "rating"
  )

ggplot(players, aes(y = reorder(name, pre_rating))) +
  geom_segment(aes(x = pre_rating, xend = post_rating, yend = name),
               size = 3,
               color = "grey",
               alpha = 0.5) +
  geom_point(aes(x = pre_rating), size = 3, color = "grey") +
  geom_point(aes(x = post_rating), size = 3, color = "blue") +
  labs(
    x = "Rating",
    y = "Player",
    title = "Player rankings after chess tournament"
  ) +
  scale_x_continuous(n.breaks = 6) +
  #theming
  theme_minimal()+
  theme(panel.grid.major.y = element_blank())#,
        #panel.grid.minor.y = element_blank(),
        #panel.grid.major.x = element_blank(),
        #panel.grid.minor.x = element_blank(),
        #axis.title.y = element_blank(),
        #axis.text.y = element_blank(),
        #axis.ticks.y = element_blank(),
        #axis.ticks.x = element_line(color = "#4a4e4d"),
        #text = element_text(family = "Segoe UI Semibold", color = "#4a4e4d"),
        #strip.text.y.left  = element_text(angle = 0),
        #panel.background = element_rect(fill = "white", color = "white"),
        #strip.background = element_rect(fill = "white", color = "white"),
        #strip.text = element_text(color = "#4a4e4d", family = "Segoe UI"),
        #plot.background = element_rect(fill = "white", color = "white"),
        #panel.spacing = unit(0, "lines"),
        #plot.margin = margin(1,1,.5,1, "cm"))

```


