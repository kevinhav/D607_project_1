---
title: "Chess Tournament Database Pipeline"
author: "Kevin Havis"
format: pdf
editor: visual
---

## Setup

```{r}
library(tidyverse)
library(purrr)
library(DBI)
library(duckdb)
library(tools)
```

## Introduction



## Loading & cleaning the data

This data is easily human-readable, however it has a couple things we need to address to get it into proper shape.

The headers, rows, and columns are delimited by ASCII characters, which we will need to strip out. We'll do this by reading each line in as a row and delimiting the columns.

```{r}

# Pre-define our initial column names
init_cols = c(
  'pairNum_state',
  'player_info',
  'total',
  'round_1',
  'round_2',
  'round_3',
  'round_4',
  'round_5',
  'round_6',
  'round_7'
)

# Create a tibble by splitting row-wise by line breaks
# and column-wise by pipe
df <- tibble(txt = read_lines('tournament_info.txt')) |> 
  separate_rows(sep = '\\n') |> 
  separate(col = txt, into = init_cols, sep = '\\|')

# Drop --- row separators
df <- na.omit(df)

# Drop secondary header
df <- df |> 
  slice(-(1:2))
```
With the extra ASCII characters cleaned up, we're in much better shape. We can now turn our attention to the stacked rows for each player. To do this, we'll group the rows and then pivot them wider into their own columns.

```{r}
# We have two rows per player so we group them and create new columns

df <- df |> 
  group_by(grp = ceiling(row_number()/2)) |> 
  mutate(row = row_number()) |> 
  pivot_wider(names_from = row, values_from = -c(row, grp)) |> 
  ungroup() |> 
  select(-grp) |> 
  mutate(across(everything(), ~ str_trim(.x)))
```

```{r}
# Update column names
col_names = c(
  "player",
  "state",
  "name",
  "rating_info",
  "total_pts",
  "n",
  "results_rd_1",
  "color_rd_1",
  "results_rd_2",
  "color_rd_2",
  "results_rd_3",
  "color_rd_3",
  "results_rd_4",
  "color_rd_4",
  "results_rd_5",
  "color_rd_5",
  "results_rd_6",
  "color_rd_6",
  "results_rd_7",
  "color_rd_7"
)

df <- df |> set_names(col_names)

```

Next, we'll need to address the concatenated values, including the "rating_info" which contains the player's USCF ID, rating before the tournament, and rating after the tournament. We'll also split the "results" columns for each round into the result (W / L) and the opponent's ID number using regex.

```{r}
# Split results columns into single columns
df <- df |> 
 separate_wider_regex(
   starts_with("results"),
   patterns = c(
     result = "[WLDBH]",
     opponent = "\\s+\\d+"),
   names_sep = "_",
   too_few = "align_start") |> 
  mutate(across(starts_with("results"), ~ str_trim(.x)))
```

```{r}
# Retrieve USCF ID
uscf_id <- df |> 
  select(rating_info) |> 
  filter(str_detect(rating_info, "[0-9]{8}")) |> 
  mutate(uscf_id = str_extract(rating_info, "([0-9]{8})")) |> 
  select(uscf_id)

# Retrieve pre_rating
pre_rating <- df |> 
  select(rating_info) |> 
  filter(str_detect(rating_info, "[0-9]{8}")) |> 
  mutate(pre_rating = str_extract(rating_info, "(?<=R:\\s{1,5})\\d+")) |> 
  select(pre_rating)

# Retrieve post_rating
post_rating <- df |> 
  select(rating_info) |> 
  filter(str_detect(rating_info, "[0-9]{8}")) |> 
  mutate(post_rating = str_extract(rating_info, "(?<=>\\s{0,5})\\d{3,4}")) |> 
  select(post_rating)

df <- df |> 
  cbind(uscf_id) |>
  cbind(pre_rating) |>
  cbind(post_rating) |>
  mutate(pre_rating = as.numeric(pre_rating)) |> 
  mutate(post_rating = as.numeric(post_rating)) |> 
  select(everything(), -rating_info)
```

We now have a well organized and "tidy" data set! 

## Save into database

While this data is useful and we could certainly perform any further analysis we'd like with it, we should store it properly in a database. This will allow us manage the data in a scalable way to accommodate new players and future tournaments.

We'll first split the data into logical tables, `players` and `rounds`. The `players` data is already well organized, but we'll add some finishing touches

```{r}
# Separate data into player table

players <- df |> 
  select(player, state, name, pre_rating, post_rating, total_pts) |> 
  mutate(rating_change = post_rating - pre_rating) |> 
  mutate(name = str_to_title(name))
```

The `rounds` table will contain information specific to this tournament. To make this more database-friendly, we'll convert the data into a long format.

```{r}
rounds <- df |>
  pivot_longer(
    cols = starts_with("results_rd_"),
    names_to = c("round", "type"),
    names_pattern = "results_rd_(\\d+)_(result|opponent)",
    values_to = "value"
  ) |>
  pivot_longer(
    cols = starts_with("color"),
    names_to = "color_col",
    values_to = "color"
  ) |> 
  pivot_wider(
    names_from = c("type"),
    values_from = c("value")
  ) |> 
  select(player, color, round, result, opponent)
```


```{r}
# Give rounds a unique ID as a key
rounds <- rounds |> 
  mutate(id = row_number())
  
conn <- DBI::dbConnect(duckdb::duckdb(), dbdir = "tournament.db")

# Write tables if they don't already exist
if (!dbExistsTable(conn, "players")) {
dbWriteTable(conn, "players", players)
} else {
  print("Table already exists, skipping write")
}


if (!dbExistsTable(conn, "rounds")) {
dbWriteTable(conn, "rounds", rounds)
} else {
  print("Table already exists, skipping write")
}


dbDisconnect(conn)
```

## Tournament Results

Now, finally, we can calculate the final results of the tournament.

## Calculate tournament stats

```{r}
average_ratings <- left_join(rounds, players, by = c("opponent" = "player")) |> 
  group_by(player) |> 
  summarize(average_opponent_rating = mean(pre_rating, na.rm = TRUE))

players <- left_join(players, average_ratings, by = "player")
```

## Build final table

```{r}
# player name, player state, total, pre_rating, average pre_rating

final_table <- players |> 
  select(player, name, state, total_pts, pre_rating, average_opponent_rating)

```

```{r fig.align="center", echo = FALSE, fig.wdith = 14, fig.height=10}
players_viz <- players |> 
  select(name, pre_rating, post_rating) |> 
  pivot_longer(
    c("pre_rating", "post_rating"),
    names_to = c("type"),
    values_to = "rating"
  )

ggplot(players, aes(y = reorder(name, pre_rating))) +
  geom_segment(aes(x = pre_rating, xend = post_rating, yend = name),
               size = 3,
               color = "grey",
               alpha = 0.5) +
  geom_point(aes(x = pre_rating), size = 3, color = "grey") +
  geom_point(aes(x = post_rating), size = 3, color = "blue") +
  labs(
    x = "Rating",
    y = "Player",
    title = "Player rankings after chess tournament"
  ) +
  scale_x_continuous(n.breaks = 6) +
  #theming
  theme_minimal()+
  theme(panel.grid.major.y = element_blank())#,
        #panel.grid.minor.y = element_blank(),
        #panel.grid.major.x = element_blank(),
        #panel.grid.minor.x = element_blank(),
        #axis.title.y = element_blank(),
        #axis.text.y = element_blank(),
        #axis.ticks.y = element_blank(),
        #axis.ticks.x = element_line(color = "#4a4e4d"),
        #text = element_text(family = "Segoe UI Semibold", color = "#4a4e4d"),
        #strip.text.y.left  = element_text(angle = 0),
        #panel.background = element_rect(fill = "white", color = "white"),
        #strip.background = element_rect(fill = "white", color = "white"),
        #strip.text = element_text(color = "#4a4e4d", family = "Segoe UI"),
        #plot.background = element_rect(fill = "white", color = "white"),
        #panel.spacing = unit(0, "lines"),
        #plot.margin = margin(1,1,.5,1, "cm"))

```


